struct ThreadPool::Data
{
    using ProviderPtr = std::shared_ptr<ThreadPoolProvider>;

    Data ();
    Data (ThreadPoolProvider *p);
    ~Data ();
    Data (const Data&)            = delete;
    Data& operator= (const Data&) = delete;

#    if defined(__cpp_lib_atomic_shared_ptr) &&                                \
        (__cpp_lib_atomic_shared_ptr >= 201711L)
    Data (Data&& other) noexcept
    {
        ProviderPtr p = other._provider.load (std::memory_order_acquire);
        _provider.store (p, std::memory_order_release);
        other._provider.store (ProviderPtr{}, std::memory_order_release);
    }
#    else
    Data (Data&&) = default;
#    endif

    Data& operator= (Data&&) = delete;

    ProviderPtr getProvider () const
    {
#    if defined(__cpp_lib_atomic_shared_ptr) &&                                \
        (__cpp_lib_atomic_shared_ptr >= 201711L)
        return _provider.load (std::memory_order_acquire);
#    else
        return std::atomic_load (&_provider);
#    endif
    }

    void setProvider (ProviderPtr provider)
    {
#    if defined(__cpp_lib_atomic_shared_ptr) &&                                \
        (__cpp_lib_atomic_shared_ptr >= 201711L)
        ProviderPtr curp =
            _provider.exchange (provider, std::memory_order_acq_rel);
#    else
        ProviderPtr curp = std::atomic_exchange (&_provider, provider);
#    endif
        if (curp && curp != provider) curp->finish ();
    }

#    if defined(__cpp_lib_atomic_shared_ptr) &&                                \
        (__cpp_lib_atomic_shared_ptr >= 201711L)
    std::atomic<ProviderPtr> _provider;
#    else
    ProviderPtr _provider;
#    endif
};